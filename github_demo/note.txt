测试demo!~LC----------
测试demo!~LC----------
!
----------------------------------------------
操作说明:

Fetch
从远程获取最新版本到本地，不会自动merge
Merge
可以把一个分支标签或某个commit的修改合并现在的分支上
Pull
从远程获取最新版本并merge到本地相当于fetch+merge
Push
将本地分支的更新，推送到远程主机
Merge tool
当你的代码产生了冲突可以通过此工具快速的对比
Switch to
将当前分支切换到其它分支或标签
Commit
将更改提交到本地库中
Rebase
可以把在一个分支里提交的改变移到另一个分支里重放一遍
Reset
将当前分支切换到本分支以前的任何一个版本状态，即所谓的“回溯”
EGit的恢复版本功能与使用Git Reset命令一样，而恢复的方式又分为Soft、Mixed、Hard三种：
•Soft:恢复到前面版本，保留文件变更内容，且将已变更的所有文件加到准备区(Staging Area)。
•Mixed:恢复到前面版本，保留所有已变更文件的变更内容。
•Hard:恢复到前面版本，不保留所有已变更文件的变更内容。
Untrack
将已经添加到版本控制的文件取消监视，及不再对其进行版本控制
Ignore
忽略指定的文件或文件夹，此功能用在还没有进行版本控制的文件上
Compare with
此功能允许你将当前文件和指定时期的文件进行对比
---------------------------------------------
 
常用操作对比:
Branch和Tag的区别：
tag多用于建立里程碑。比如开发达到某中程度，发布某个版本，如V1.0，可以使用tag标注。这样，以后对于程序版本号就可以找到对应的代码状态，并进行build等操作。理论上，tag作为里程碑的镜像存储，应该是只读的才对。
相比，branch是工程需要并行开发不同版本而创建的。如一个原型项目完成后，可能有不同的客户购买并定制，于是就需要在这个原型上构建两个独立的开发库，各自并行开发不同客户的需要。这样，branch可以是进程中的工程，而且之后会不断修改的。
由此，可以看出tag和branch的差别。tag更重要的是记录某个里程碑，只是希望得到那个状态时的代码状态，这对bug的确认和查找很有用处。而各个branch之间是可以肆意各自的改动，互不相干的，branch上也可以有自己的tag。
-----------------------------------------------------------
Merge和Rebase的区别：
下面通过一个实例来讲解一下两种方式的区别：
假设原先有A,B,C三个提交记录
A-B-C
开发者提交了D,开发者 Ed提交了E
A-B-C-D-E
下面使用MERGE和REBASE两种方式分别对代码进行合并
MERGE方式:
A-B-C-D-E-M
这时D和E的提交仍然在这，但是我们创建了一个新的提交记录M，此时的状态图成了一个菱形，这让很多人看起来很混乱。
REBASE方式:
A-B-C-D-E-R
从上图可以看出这种方式创建了提交R，这时的内容和M实际上是相同的。但是这时没有了E，所以整个提交记录是看起来是一条线。